---
title: 20201212の調べ
date: 2020-12-12 10:19:56
tags:
---

## Apple M1関連
- M1
	- ISA: ARM 64
	- 強さ
		- メモリ性能とIO性能が高い
	- M1で動くアプリ
		- ARM64 nativeアプリ
		- x86-64--Rosetta-->ARM64
		
	- Intelと比較
		- intelに最適化されてると勝てない
		
- Rosettaは何者？
	- x86-64 CISC -> ARM64のコンパイラ　not インタプリタ
	- M1がApple設計なので、OoO実行などCPUレベルの最適化もきっと入っているだろう
	
## Docker関連
- 参考
    - [Don't Panic: Kubernetes and Docker \| Kubernetes](https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/)
    - [Kubernetes 1\.20からDockerが非推奨になる理由 \- inductor's blog](https://blog.inductor.me/entry/2020/12/03/061329)
    - [KubernetesのDockershim廃止における開発者の対応 \- inductor's blog](https://blog.inductor.me/entry/2020/12/03/144834)

- Kubernetes - Container Runtime　のインタフェースをCRI (Container Runtime Interface)と呼ぶ
- DockerがCRIをサポートしていないので、`dockershim`というブリッジが Docker API-CRIの変換をしていたが、ここがdeprecateになる
- そもそも、Dockerの機能のうち、Kubernetesが使用するのはコアなランタイムのみ（containerd)
    - [containerd/containerd: An open and reliable container runtime](https://github.com/containerd/containerd/)
    - Dockerに内包されているが、DockerがCRIに対応していないので、`dockershim`が必要だった


- Kubernates
    - Red Hatのdistribution: OpenShift
        - ここで使われるのは、cri-o というランタイム

- Container Runtimeの構造
    - High Level Runtime(CRI Runtime)
        - e.g. containerd, cri-o
        - kuberlet とやりとりする
    - Low Level Runtime(OCI Runtime)
        - runC, gVisor
        - CRI Runtimeとやりとりする

- 影響まとめ
    - でも、Dockerにはcontainerdが内包されているので、互換性は高い
    - Docker-produced images will continue to work in your cluster with all runtimes, as they always have.
    - Docker is still a useful tool for building containers, and the images that result from running docker build can still run in your Kubernetes cluster.

    - The image that Docker produces isn’t really a Docker-specific image -- it’s an OCI (Open Container Initiative) image. 
    - Any OCI-compliant image, regardless of the tool you use to build it, will look the same to Kubernetes. 
    - Both containerd and CRI-O know how to pull those images and run them.

- コンテナの仕組みってそもそもなんだ・・
    - Linuxの`chroot`のすごいバージョンである
        - 特定のディレクトリをrootにして、それ以下のみの世界を作る技術
    - そのファイルシステムに対して、`namespace`でユーザやプロセス、NWを割り当て
    - `cgroups`でリソースの制御をかける
    - そして、VMのように扱える　という技術
- コンテナイメージ
    - DebianとかUbuntuが動く最低限のファイルシステムを含んだものをtarしたもの

- runCの仕組み
    - ホストOS・カーネルは、マシンごとに共通である
    - 特権が必要なので、runCに脆弱性があると、危険
- gVisorの仕組み
    - Linux上でプロセスとして動くゲストカーネル
    - gVisorの上で複数コンテナが動き、コンテナのシステムコールをptraceでフックし、gVisorが代理実行する

## Kotlin関連
- null safety関連の機能
- Javaからの移行はどうなるんだろう？
    - Kotlin自体もJVMで動く
    - Java-Kotlin間は相互運用可能（お互いにcallable)
    - Spring Initializerでも、Kotlinを既にサポートしている
    - 言語的に大きくJavaに対して優位性があれば切り替えられるが・・・
        - 実際には会社や世の中の開発者のスキルセット　とか
        - 既存アセット
        - に引っ張られて、すぐに変わる原動力にはならなそう。個人的には気になる

## Pen, offensive security
- Hack the box, VolnHub, TryHackMe というサービスがある
- VolnHub: 脆弱性ありのVMイメージ配布サイト
    - [Vulnerable By Design ~ VulnHub](https://www.vulnhub.com/)
    - 初学者向けではないな。練習用